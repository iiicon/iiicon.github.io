<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans,en,default">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="coding note and life perception 代码笔记和生活感悟">
<meta property="og:type" content="website">
<meta property="og:title" content="一个没有情趣和色彩的人">
<meta property="og:url" content="https://sgw.wiki/page/3/index.html">
<meta property="og:site_name" content="一个没有情趣和色彩的人">
<meta property="og:description" content="coding note and life perception 代码笔记和生活感悟">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个没有情趣和色彩的人">
<meta name="twitter:description" content="coding note and life perception 代码笔记和生活感悟">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sgw.wiki/page/3/">





  <title>一个没有情趣和色彩的人</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个没有情趣和色彩的人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">正经点 少说话</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/12/16/《高程三》读书笔记第六章面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/16/《高程三》读书笔记第六章面向对象/" itemprop="url">《高程三》读书笔记第六章面向对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-16T00:46:52+08:00">
                2019-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><p>分为两种 数据属性和访问器属性</p>
<p>数据属性有 [[configurable]] [[Enumerable]] [[Writeable]] [[Value]] 四个特性，value 也是数据的值</p>
<p>访问器属性有 [[Configurable]] [[Enumberable]] [[Get]] [[Set]] 四个特性，一般情况下包括一对 getter 和 setter<br>访问器属性不能直接定义，必须使用 Object.defineProperty</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>抽象了创建具体对象的过程的函数</p>
<p>工厂模式虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>构造函数的问题就是每个方法都要在构造函数上重新实现一遍</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>让所有对象实例共享它所包含的属性和方法<br>主要问题就是共享的引用类型的数据会有问题</p>
<h3 id="组合使用构造函数模式和原型模式（最大限度地节省内存）"><a href="#组合使用构造函数模式和原型模式（最大限度地节省内存）" class="headerlink" title="组合使用构造函数模式和原型模式（最大限度地节省内存）"></a>组合使用构造函数模式和原型模式（最大限度地节省内存）</h3><p>这是目前在 js 中使用最广泛、认同度最高的一种创建自定义类型的方法</p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>在构造函数中动态创建原型</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>就是返回一个函数，这个函数创建一个新的对象，对象做增强<br>（比如我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数）</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>禁止使用的时候可以用</p>
<h2 id="继承对象"><a href="#继承对象" class="headerlink" title="继承对象"></a>继承对象</h2><p>一般有接口继承和实现继承，js 是实现继承</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>主要是为了分开实例属性和原型属性，原型属性要公用，实例属性却不能<br>可以在子构造函数中调用 超类的构造函数</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承避免了原型链和构造函数的缺陷，融合了他们的优点，称为了 JavaScript 中最常用的继承模式</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 <code>Object.create()</code> 的功效是一样的<br>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象（感觉就是在原来的对象的基础上修改 就是返回另一个对象）</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>解决组合继承调用两次的问题，感觉也。。无所谓的呀</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/12/12/《深入理解ES6》读书笔记ES6中较小的改动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/12/《深入理解ES6》读书笔记ES6中较小的改动/" itemprop="url">《深入理解ES6》读书笔记ES6中较小的改动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-12T23:43:55+08:00">
                2019-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="使用整数"><a href="#使用整数" class="headerlink" title="使用整数"></a>使用整数</h3><h4 id="判断整数-Number-isInteger"><a href="#判断整数-Number-isInteger" class="headerlink" title="判断整数 Number.isInteger"></a>判断整数 Number.isInteger</h4><p>如果有些数字看起来像浮点数，却存储为整数，这会让 Number.isInteger 方法判断失效而返回 true<br>在 javascript 中，只给数字添加小数点不会让整数变为浮点数，此处的 25.0 确实是 25，所以会按照整数的形式存储</p>
<h4 id="安全整数-Number-isSafeInteger"><a href="#安全整数-Number-isSafeInteger" class="headerlink" title="安全整数 Number.isSafeInteger"></a>安全整数 Number.isSafeInteger</h4><p>Number.isSafeInteger 方法来识别语言可以准确得表示的整数，添加了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 分别表示整数范围的上限和下限。Number.isSafeInteger 方法用来确保一个值是整数，并且落在整数值的安全范围内</p>
<h3 id="新的-Math-方法"><a href="#新的-Math-方法" class="headerlink" title="新的 Math 方法"></a>新的 Math 方法</h3><p>ES6 引入定型数组来增强游戏和图形体验，这可以让 js 引擎做更有效的数字计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.hypot 求平方和根</span><br><span class="line">Math.sign 返回 1 -1 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="正式化-proto-属性"><a href="#正式化-proto-属性" class="headerlink" title="正式化 proto 属性"></a>正式化 <strong>proto</strong> 属性</h3><p>不是所有的 js 引擎 都实现了 <strong>proto</strong>, 所以 ES6 正式添加了这个特性，但有一段警告</p>
<blockquote>
<p>这些特性本属于 es 核心语言的一部分，在编写新的 es 代码时，程序员不应该使用这些特性和功能，也不应假定它们是存在的。除非在 web 浏览器中或者需要像 web 浏览器一样执行遗留的 es 代码，否则不鼓励</p>
</blockquote>
<p>所以更应该用 <code>Object.getPrototype()</code> 和 <code>Object.setPrototype()</code></p>
<p>在 es6 引擎中 <code>Object.prototype.__proto__</code> 被定义为一个访问器属性，其 get 方法会调用 <code>Object.getPrototype</code>，set 方法会调用 <code>Object.setPrototype</code>, 因此和使用 <strong>proto</strong> 的区别就是可以直接设置对象字面量的原型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/12/12/《深入理解ES6》读书笔记了解 ES7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/12/《深入理解ES6》读书笔记了解 ES7/" itemprop="url">《深入理解ES6》读书笔记了解ES7</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-12T23:23:12+08:00">
                2019-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><pre><code>let result = 5 ** 2
consol.log(result === Math.pow(5,2))
</code></pre><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><pre><code>let result = 2 * 5 ** 2 // 50
</code></pre><h3 id="运算限制"><a href="#运算限制" class="headerlink" title="运算限制"></a>运算限制</h3><p>取幂运算符的左侧的一元表达式只能使用 ++ 或者 –</p>
<pre><code>let result = -5 ** 2 // error
let result = -(5**2)
</code></pre><h2 id="Array-prototype-includes-方法"><a href="#Array-prototype-includes-方法" class="headerlink" title="Array.prototype.includes() 方法"></a>Array.prototype.includes() 方法</h2><p>第一个参数是要搜索的值，第二个参数是开始搜索的位置，返回 true 或者 false</p>
<h3 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h3><pre><code>let values = [1, NaN, 2]
console.log(values.indexOf(NaN)) // -1
console.log(values.includes(NaN)) // true
</code></pre><p>如果你只想检查数组中是否存在某个不知道索引的值，由于给 includes() 方法和 indexOf() 方法传入 NaN 的差异，这里建议使用 includes() 方法，如果你想知道某个值在数组的哪个位置，则必须使用 indexOf() 方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/12/12/从「从输入URL到页面加载」谈及Web性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/12/从「从输入URL到页面加载」谈及Web性能优化/" itemprop="url">从「从输入URL到页面加载」谈及Web性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-12T15:40:59+08:00">
                2019-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web-性能/" itemprop="url" rel="index">
                    <span itemprop="name">web 性能</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="如何理解-web-性能优化"><a href="#如何理解-web-性能优化" class="headerlink" title="如何理解 web 性能优化"></a>如何理解 web 性能优化</h3><p>一个网站的性能，可以分为两个方面，一个叫做 Loading Performance（加载性能），一个叫做 Rendering Performce（渲染性能），说白了就是用户觉得页面加载很快</p>
<p><img src="https://user-images.githubusercontent.com/25027560/46640041-5703be80-cb9c-11e8-8974-5cd0d71ead5f.png" alt="浏览器原理"></p>
<h3 id="从输入-URL-到页面加载发生了什么"><a href="#从输入-URL-到页面加载发生了什么" class="headerlink" title="从输入 URL 到页面加载发生了什么"></a>从输入 URL 到页面加载发生了什么</h3><p>从各个阶段寻求优化</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/28/163a4d01fdd197b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="浏览器缓存"></p>
<p>输入地址后又缓存直接读缓存，没有就直接请求</p>
<h4 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h4><p>DNS 查询就像电话簿，你再浏览器地址输入地址，通过 DNS 查询得到域名的真实 IP<br>DNS 查询完成之前，浏览器无法从服务器下载任何资源</p>
<p>优化：就需要减少 DNS 查询</p>
<ul>
<li>DNS 缓存</li>
<li>减少域名</li>
</ul>
<h4 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h4><p><img src="https://i.loli.net/2019/12/12/W2kKG78ybpLvcPu.png" alt="20191212171414.png"></p>
<p>优化：</p>
<ul>
<li>http 请求头 <code>Connection:keep-alive</code></li>
<li>http2.0 多路复用</li>
</ul>
<h4 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h4><h5 id="不要滥用-cookie"><a href="#不要滥用-cookie" class="headerlink" title="不要滥用 cookie"></a>不要滥用 cookie</h5><ul>
<li>去除不必要的 cookie</li>
<li>尽量压缩 cookie</li>
<li>注意 设置 cookie 的 domain 级别，不要影响 sub-domain</li>
<li>设置合适的过期时间</li>
<li>静态资源使用无 cookie 的域名</li>
</ul>
<h5 id="添加-Expires-或-Cache-Control-响应头"><a href="#添加-Expires-或-Cache-Control-响应头" class="headerlink" title="添加 Expires 或 Cache-Control 响应头"></a>添加 Expires 或 Cache-Control 响应头</h5><ul>
<li>静态内容：将 Expires 响应头设置为将来很远的时间，实现「永不过期」策略</li>
<li>动态内容：设置合适的 Cache-Control 响应头，让浏览器有条件地发起请求。</li>
</ul>
<h5 id="设置-Etag"><a href="#设置-Etag" class="headerlink" title="设置 Etag"></a>设置 Etag</h5><p>通过如 MD5 等加密算法，设置缓存体的 Etag 配合 3.3 的缓存时间使用，这样 Cache-Control 就可以设置较长时间（max-age 设置个十年半载 ），只要浏览器缓存中资源与源服务器中的资源 Etag 不一致，说明内容更新了，此时再下载新资源；Etag 匹配成功则直接响应 304，不用重复下载了用户自然感觉很快。</p>
<h5 id="使用-Gzip"><a href="#使用-Gzip" class="headerlink" title="使用 Gzip"></a>使用 Gzip</h5><p>使用 Gzip 就是将 HTML CSS JS XML JSON 等资源进行 Gzip 高效压缩，减少资源体积那么下载就会更快，Gzip 压缩通常可以达到 70%，对某些文件可以达到 90%，比 Deflate 更高效。主流服务器都有相应的模块，绝大多数浏览器支持 Gzip 解码，从 http1.1 开始客户端就有了支持压缩的 <code>Accept-Encoding:gzip,deflate</code> 请求头</p>
<p>服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web 服务器通过 Content-Encoding 响应头来通知客户端。<code>Content-Encoding: gzip</code></p>
<p><strong>注意</strong>已经压缩过的内容如图片和 pdf 不要使用 Gzip，另外还有文件内容本身就很小，这些资源再使用 Gzip 反而会增加资源下载时间，浪费 cpu 资源，可能还会增加文件体积</p>
<h5 id="请求数量"><a href="#请求数量" class="headerlink" title="请求数量"></a>请求数量</h5><p>http 请求的另一个优化方案是增加同时请求的数量，浏览器会同时发送多个请求（cdn），但是同一个域名最多发动 4-8 个，那么当资源过多时，就可以通过增加域名的方法增加并发下载，当然这和上面的 DNS 查询相悖，真实的线上要做权衡</p>
<h5 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h5><p>因为一次发送的请求有限，所以重要的资源要优先加载，动态的要异步加载</p>
<!-- TODO: script module -->
<h5 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h5><p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p>
<!-- TODO: script module -->
<h4 id="接受相应"><a href="#接受相应" class="headerlink" title="接受相应"></a>接受相应</h4><p>同样是压缩 Gzip 和利用缓存 Etag 等，响应完成就代表浏览器下载完资源了</p>
<h4 id="接受完成，解析-HTML"><a href="#接受完成，解析-HTML" class="headerlink" title="接受完成，解析 HTML"></a>接受完成，解析 HTML</h4><p>（Gzip 压缩）<br>接受完成后开始逐行解析 html 文件</p>
<h5 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h5><p>一定要写对 DOCTYPE<br>这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“怪异模式(兼容模式)”的渲染模式。“&lt;!DOCTYPE html&gt;” 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。</p>
<h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><p>合并css 减少请求数<br>浏览器会并行下载css，然后逐个解析<br>把样式表放在 head 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉，有些浏览器会在 css 加载完成之后才会渲染页面<br>我们知道不管是 css 还是 js 都会阻塞页面的渲染（比如chrome中css就会）<br>而且 GUI 线程和 js引擎是互斥的，只有一方能工作，所以一般 css 写上面， js写下面，这样更加符合浏览器的工作原理</p>
<h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><p>合并js，减少请求数<br>浏览器会并行下载 js，然后逐个解析<br>而且 <code>&lt;script&gt;</code> 一定阻塞页面 // 待确认<br>放在body最后，可以尽早显示页面，还可以获取节点</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/12/06/h5项目总结（xl2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/h5项目总结（xl2）/" itemprop="url">h5项目总结（xl2）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T10:01:55+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在-xl-基础上做如下优化"><a href="#在-xl-基础上做如下优化" class="headerlink" title="在 xl 基础上做如下优化"></a>在 xl 基础上做如下优化</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>文件用 kebab case<br>变量 camel case<br>组件用 kebab case （个人偏好， 尤小右推荐用 Pascal case）</p>
<p>html 部分<br>属性尽量用 kebab case<br>id 用 camel case<br>类名用 kebab case</p>
<h3 id="关于-toast"><a href="#关于-toast" class="headerlink" title="关于 toast"></a>关于 toast</h3><p>在 vue.prototype 上注册一个全局的 Toast，方便在组件中和 js 文件的任何地方调用<br>主要是得益于 cube-ui 的 createAPI</p>
<h3 id="关于-Loading"><a href="#关于-Loading" class="headerlink" title="关于 Loading"></a>关于 Loading</h3><p>也是利用 createAPI 的全局注册一个组件，可以用 api 调用组件</p>
<h3 id="全局注入文件，以便每个文件使用"><a href="#全局注入文件，以便每个文件使用" class="headerlink" title="全局注入文件，以便每个文件使用"></a>全局注入文件，以便每个文件使用</h3><p>完成公共样式的抽离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css: &#123;</span><br><span class="line">  loaderOptions: &#123;</span><br><span class="line">    sass: &#123;</span><br><span class="line">      data: `</span><br><span class="line">        @import &quot;@/assets/css/variable.scss&quot;;</span><br><span class="line">        @import &quot;@/assets/css/cover-cube.scss&quot;;</span><br><span class="line">        @import &quot;@/assets/css/public.scss&quot;;</span><br><span class="line">      `</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="退出多层路由"><a href="#退出多层路由" class="headerlink" title="退出多层路由"></a>退出多层路由</h3><h3 id="input-click"><a href="#input-click" class="headerlink" title="input click"></a>input click</h3><p>点击事件需要加 native</p>
<h3 id="在-vuex-层做数据持久化"><a href="#在-vuex-层做数据持久化" class="headerlink" title="在 vuex 层做数据持久化"></a>在 vuex 层做数据持久化</h3><p>默认方式采用 sessionstorage 存储<br>需要挑出使用 localstorage 存储的属性和 不需要存储的属性</p>
<p>下面贴出 vuex 配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import state from &apos;./state&apos;</span><br><span class="line">import getters from &apos;./getters&apos;</span><br><span class="line">import mutations from &apos;./mutations&apos;</span><br><span class="line">import actions from &apos;./actions&apos;</span><br><span class="line">import createPersistedstate from &apos;vuex-persistedstate&apos;</span><br><span class="line">import createLogger from &apos;vuex/dist/logger&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const debug = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class="line"></span><br><span class="line">// 完全不需要存储的属性放在这里，默认的是要存储 sessionstorage</span><br><span class="line">const pathWithoutLSAndSS = []</span><br><span class="line"></span><br><span class="line">// 需要 localstorage 不能存 sessionstorage 的放在这里</span><br><span class="line">const pathWithoutSS = [&apos;authToken&apos;]</span><br><span class="line"></span><br><span class="line">const vuexWithSS = createPersistedstate(&#123;</span><br><span class="line">  key: &apos;SS&apos;,</span><br><span class="line">  storage: window.sessionStorage,</span><br><span class="line">  reducer: (vuexState) =&gt; &#123;</span><br><span class="line">    let sessionState = Object.assign(&#123;&#125;, vuexState)</span><br><span class="line">    let path = [...pathWithoutSS, ...pathWithoutLSAndSS]</span><br><span class="line"></span><br><span class="line">    path.forEach(item =&gt; &#123;</span><br><span class="line">      if (sessionState.hasOwnProperty(item)) &#123;</span><br><span class="line">        delete sessionState[item]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return vuexState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const vuexWithLS = createPersistedstate(&#123;</span><br><span class="line">  key: &apos;LS&apos;,</span><br><span class="line">  storage: window.localStorage,</span><br><span class="line">  reducer: (vuexState) =&gt; &#123;</span><br><span class="line">    let storage = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    pathWithoutSS.forEach(item =&gt; &#123;</span><br><span class="line">      if (vuexState.hasOwnProperty(item)) &#123;</span><br><span class="line">        storage[item] = vuexState[item]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return storage</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line"></span><br><span class="line">  // 在开发环境打开严格模式，虽然还是可以被修改，但是会在控制台报错</span><br><span class="line">  strict: debug,</span><br><span class="line"></span><br><span class="line">  // 使用插件存储 vuex 数据到 storage, 同时要在开发环境打开 logger</span><br><span class="line">  plugins: debug ? [createLogger(), vuexWithSS, vuexWithLS] : [vuexWithSS, vuexWithLS]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default store</span><br></pre></td></tr></table></figure>
<p>vuex persist API 文档</p>
<p><img src="https://i.loli.net/2019/07/09/5d2425ba6317133933.jpg" alt="1562649994(1).jpg"></p>
<h3 id="利用-promise-解析-res-data"><a href="#利用-promise-解析-res-data" class="headerlink" title="利用 promise 解析 res.data"></a>利用 promise 解析 res.data</h3><p>优化前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post(url, data, options = &#123;&#125;) &#123;</span><br><span class="line">  const instance = axios.create(this.getFixedConfig())</span><br><span class="line">  this.interceptors(instance)</span><br><span class="line">  return instance.post(url, data, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">post(url, data, options = &#123;&#125;) &#123;</span><br><span class="line">  const instance = axios.create(this.getFixedConfig())</span><br><span class="line">  this.interceptors(instance)</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    instance.post(url, data, options).then(res =&gt; &#123;</span><br><span class="line">      resolve(res.data)</span><br><span class="line">    &#125;, err =&gt; &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取-accessToken-优化"><a href="#获取-accessToken-优化" class="headerlink" title="获取 accessToken 优化"></a>获取 accessToken 优化</h3><ul>
<li><p>优化前<br>在 mian.js 中调用获取 accessToken 的接口</p>
</li>
<li><p>优化后<br>写一个 getToken 的 js 文件，在 login register getpass 三个页面调用，统一存储到 vuex</p>
</li>
<li><p>优化空间<br>再存储一个过期时间，没有过期就不再继续请求，直接读取 vuex 中的值</p>
</li>
</ul>
<h3 id="xl-需要的改动"><a href="#xl-需要的改动" class="headerlink" title="xl 需要的改动"></a>xl 需要的改动</h3><ul>
<li>意见反馈增加参数</li>
<li>退出登录加类型</li>
</ul>
<h3 id="ljl-需要优化点"><a href="#ljl-需要优化点" class="headerlink" title="ljl 需要优化点"></a>ljl 需要优化点</h3><ul>
<li>时间选择初始化</li>
<li>数据可能获取比较慢，在表单数据获取之后 refresh scroll</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/12/03/git分支合并相关操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/git分支合并相关操作/" itemprop="url">git分支合并相关操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T09:50:56+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>分支合并的一些操作我们经常会遇到</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/03/git分支合并相关操作/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/11/29/内存泄漏和一次移动端导致的页面崩溃/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/29/内存泄漏和一次移动端导致的页面崩溃/" itemprop="url">内存泄漏和一次移动端导致的页面崩溃</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-29T17:30:27+08:00">
                2019-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web-性能/" itemprop="url" rel="index">
                    <span itemprop="name">web 性能</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="工作中遇到的内存泄漏"><a href="#工作中遇到的内存泄漏" class="headerlink" title="工作中遇到的内存泄漏"></a>工作中遇到的内存泄漏</h3><p>最近在做一个数据图表的项目，有用阿里的 AntV 移动端组件 F2，项目是 vue 的 spa 项目，起初的状况就是切换页面大概在30次左右就会导致 F2 不渲染，白屏。刚开始分析是因为脚本加载阻塞导致的，后来打开 chrome 的 performance 测了一下才知道原来是比较严重的内存泄漏，由 F2 创建的图表上的事件和属性在页面切换的时候并不会被 GC，经过查找文档，尝试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chart.clear() // 清除画布</span><br><span class="line">chart.destroy() // 销毁 chart 对象以及监听的事件</span><br><span class="line">chart = null // 指向 null，在下个周期 GC</span><br></pre></td></tr></table></figure>
<p>终于在 vue 的 beforeDestory 生命周期执行上述操作，终于把内存占用稍稍稳定了<br><img src="https://i.loli.net/2019/11/29/fn3eFaY7ubUsWqP.png" alt="60快照.png"></p>
<h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><blockquote>
<p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。<br>大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。</p>
</blockquote>
<h3 id="怎么识别内存泄漏"><a href="#怎么识别内存泄漏" class="headerlink" title="怎么识别内存泄漏"></a>怎么识别内存泄漏</h3><ol>
<li>使用 Chrome 任务管理器实时监视内存使用 打开 chrome 浏览器，点击右上角主菜单，选择更多工具-&gt;任务管理器，这样就开启了任务管理器面板，然后再右键点击任务管理器的表格标题并启用 JavaScript 使用的内存</li>
</ol>
<p>内存占用空间(Memory) 列表示原生内存。DOM 节点存储在原生内存中。 如果此值正在增大，则说明正在创建 DOM 节点。<br>JavaScript 使用的内存(JavaScript Memory) 列表示 JS 堆。此列包含两个值。 您感兴趣的值是实时数字（括号中的数字）。实时数字表示您的页面上的可到达对象正在使用的内存量。 如果此数字在增大，要么是正在创建新对象，要么是现有对象正在增长。</p>
<ol start="2">
<li>利用 chrome 时间轴记录可视化内存泄漏</li>
<li>使用堆快照发现已分离 DOM 树的内存泄漏</li>
</ol>
<h3 id="内存泄漏发生的原因"><a href="#内存泄漏发生的原因" class="headerlink" title="内存泄漏发生的原因"></a>内存泄漏发生的原因</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>有时候为了方便数据的快捷复用，我们会使用缓存，但是魂村必须有一个大小上仙才有用，高内存消耗将会导致缓存突破上限，因为缓存内容无法被回收</p>
<h4 id="队列销毁不及时"><a href="#队列销毁不及时" class="headerlink" title="队列销毁不及时"></a>队列销毁不及时</h4><p>当浏览器队列销毁不及时时，会导致一些作用域变量得不到及时的释放，因而导致内存泄漏</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>除了常规设置了比较大的对象在全局变量中，还可能是意外导致的全局变量</p>
<pre><code>function foo(arg) {
    bar = &quot;this is a hidden global variable&quot;;
}
</code></pre><h4 id="计时器中引用没有清除"><a href="#计时器中引用没有清除" class="headerlink" title="计时器中引用没有清除"></a>计时器中引用没有清除</h4><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>例如，Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏。当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏。</p>
<h3 id="避免内存泄漏的方法"><a href="#避免内存泄漏的方法" class="headerlink" title="避免内存泄漏的方法"></a>避免内存泄漏的方法</h3><ol>
<li>少用全局变量，避免意外产生的全局变量</li>
<li>使用闭包要及时注意，有 dom 元素的引用要及时清理</li>
<li>计时器里的回调没用的时候要记得销毁</li>
<li><p>为了避免疏忽导致的遗忘，我们可以用 WeakSet 和 WeakMap 结构，他们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用</p>
<pre><code>const wm = new WeakMap();

const element = document.getElementById(&apos;example&apos;);

wm.set(element, &apos;some information&apos;);
wm.get(element) // &quot;some information&quot;
</code></pre></li>
</ol>
<p>这种情况下，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/11/02/玩转webstorm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/02/玩转webstorm/" itemprop="url">玩转 WebStorm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-02T10:47:27+08:00">
                2019-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="webstorm-各种操作"><a href="#webstorm-各种操作" class="headerlink" title="webstorm 各种操作"></a>webstorm 各种操作</h3><p>两个系统不一样的只要自己试了…</p>
<h3 id="win"><a href="#win" class="headerlink" title="win"></a>win</h3><ul>
<li>两次 shift 搜索, .css 搜索所有 css 文件，可以多选打开</li>
<li>新建文件，选中对应的文件夹， <code>ctrl insert</code></li>
<li>new Card() 之后按 <code>ctrl alt v</code> 直接给你命名</li>
<li>删除一行 <code>ctrl y</code></li>
<li>补全已经写过的单词 ctrl+slash <code>ctrl /</code> (很智能)</li>
<li>下拉提示 <code>ctrl shift space</code></li>
<li><code>div&gt;lorem5</code> 可以输出测试用的胡乱文字</li>
<li><code>ctrl w</code> 增量选择代码块</li>
<li><code>ctrl e</code> 打开文件</li>
<li><code>ctrl shift f10</code> run</li>
<li><code>ctrl shift f8</code> 查看断点</li>
<li><code>ctrl r</code> 查找替换</li>
<li><code>ctrl shift n</code> 查找文件</li>
</ul>
<h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><ul>
<li><code></code> // 增量选择代码块 // TODO</li>
<li><code>cmd + shift + ]/[</code> 切换文件</li>
<li>多行光标 自己配的 clone caret above<code>ctrl alt ↑</code> 和 clone caret below<code>ctrl alt ↓</code></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/10/31/面向对象之继承（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/31/面向对象之继承（二）/" itemprop="url">面向对象之继承（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-31T16:32:14+08:00">
                2019-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><pre><code>function 士兵(ID) {
  this.ID = ID
  this.生命值 = 42
}
士兵.原型 = {
  兵种: &apos;步兵&apos;,
  攻击力: 5,
  行走: function () { },
  奔跑: function () { },
  死亡: function () { },
  攻击: function () { },
  防御: function () { },
}
var 士兵们 = []
for (var i = 0; i &lt; 100; i++) {
  士兵们.push(new 士兵(i))
}
 兵营.批量制造(士兵们)
</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>function createSoldier(name) {
this.id = i // ID 不能重复
this.生命值 = 42
this.name = name || &apos;无名战士&apos;
}
createSoldier.prototype.兵种 = &quot;美国大兵&quot;
createSoldier.prototype.攻击力 = 5
createSoldier.prototype.行走 = function () { /_走俩步的代码_/ }
createSoldier.prototype.奔跑 = function () { /_狂奔的代码_/ }
createSoldier.prototype.死亡 = function () { /_Go die_/ }
createSoldier.prototype.攻击 = function () { /_糊他熊脸_/ }
createSoldier.prototype.防御 = function () { /_护脸_/ }

var soldiers = []
for (var i = 0; i &lt; 100; i++) {
soldiers.push(new createSoldier())
}

// 兵营.batchMake(soldiers)
</code></pre><h3 id="习俗"><a href="#习俗" class="headerlink" title="习俗"></a>习俗</h3><ol>
<li>构造函数首字母大写</li>
<li>构造函数可以省掉 create</li>
<li>如果构造函数没有参数，那么可以省略括号</li>
</ol>
<h3 id="继承的代码"><a href="#继承的代码" class="headerlink" title="继承的代码"></a>继承的代码</h3><pre><code>function Human(options) {
this.name = options.name
this.肤色 = options.肤色
}
Human.prototype.eat = function () { }
Human.prototype.drink = function () { }
Human.prototype.poo = function () { }

function Soldier(options) {
Human.call(this, options)
this.id = options.id
this.生命值 = 100
}
Soldier.prototype = Object.create(Human.prototype)
// 大脑中的
// Soldier.prototype.**proto** = Human.prototype
Soldier.prototype.兵种 = &quot;美国大兵&quot;
Soldier.prototype.攻击力 = 5
Soldier.prototype.行走 = function () { /_走俩步的代码_/ }
Soldier.prototype.奔跑 = function () { /_狂奔的代码_/ }
Soldier.prototype.死亡 = function () { /_Go die_/ }
Soldier.prototype.攻击 = function () { /_糊他熊脸_/ }
Soldier.prototype.防御 = function () { /_护脸_/ }

var s = new Soldier({ name: &apos;ergou&apos;, 肤色: &apos;yellow&apos;, id: 1 })
console.dir(s)

// 改成 class 的写法
class Human {
constructor(options) {
this.name = options.name
this.肤色 = options.肤色
}
eat() { }
drink() { }
poo() { }
}

class Soldier extends Human {
constructor(options) {
super(options)
this.id = options.id
this.生命值 = 100
this.兵种 = &quot;美国大兵&quot;
this.攻击力 = 5
}
行走() { /_走俩步的代码_/ }
奔跑() { /_狂奔的代码_/ }
死亡() { /_Go die_/ }
攻击() { /_糊他熊脸_/ }
防御() { /_护脸_/ }
}
</code></pre><h3 id="真的是继承吗"><a href="#真的是继承吗" class="headerlink" title="真的是继承吗"></a>真的是继承吗</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sgw.wiki/2019/10/31/面向对象之构造函数的由来/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iiicon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个没有情趣和色彩的人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/31/面向对象之构造函数的由来/" itemprop="url">面向对象之构造函数的由来</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-31T16:22:03+08:00">
                2019-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>对象和对象的关系（原型链）<br>对象和函数的关系（this）</p>
</blockquote>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code>var person1 = {
  name: &apos;frank&apos;,
  age: 18,
  isAdult: true,
  say() {
    console.log(`I am ${this.name}`)
  }
}
var person2 = {
  name: &apos;jack&apos;,
  age: 18,
  isAdult: true,
  say() {
    console.log(`I am ${this.name}`)
  }
}
var person3 = {}
var person4 = {}
</code></pre><p>这些对象太类似了，于是我们发明了构造函数（返回对象的函数，一般首字母大写）</p>
<pre><code>function createPerson(name, age) {
  var object = {}
  object.name = name
  object.age = age
  object.isAdult = age &gt;= 18 // 这就是计算属性，因为是计算出来的属性
  object.say = function () {
    console.log(`I am ${this.name}`) // this 可能是 object 也可能不是
  }

  return object
}
</code></pre><p>没有必要给每个 object 创建一个匿名函数（object.say 指向的匿名函数），所以我们创建一个对象，包含所有共用属性</p>
<pre><code>var personCommonAttrs = {
  say: function () {
    console.log(`I am ${this.name}`)
  }
}
function createPerson(name, age) {
  var object = {}
  object.name = name
  object.age = age
  object.isAdult = age &gt;= 18
  object.__proto__ = personCommonAttrs // __proto__ 是私有属性，不要在生产环境使用 __proto__, 请使用 Object.create

  return object
}
</code></pre><p>很多人觉得不爽，把 personCommonAttrs 改为 createPerson 的属性</p>
<pre><code>createPerson.personCommonAttrs = {
  say: function () {
    console.log(`I am ${this.name}`)
  }
}
function createPerson(name, age) {
  var object = {}
  object.name = name
  object.age = age
  object.isAdult = age &gt;= 18
  object.__proto__ = personCommonAttrs // __proto__ 是私有属性，不要在生产环境使用 __proto__, 请使用 Object.create

  return object
}
</code></pre><p>接下来我们创建狗</p>
<pre><code>function createDog(name, age) {
  var object = {}
  object.name = name
  object.name = age
  object.isAdult = age &gt;= 2.6
  object.__proto__ = createDog.dogCommonAttr

  return object
}
createDog.dogCommonAttr = {
  say: function () {
    console.log(`狗子汪汪汪`)
  }
}
</code></pre><p>对比人的代码和狗的代码，你会发现 xxxCommonAttrs 这个名字完全就是多此一举，不如叫做 personCommonAttrs 然后一些程序员把 commonAttrs 重命名为 prototype</p>
<p>然后上面的代码就变成了</p>
<pre><code>function createDog(name, age) {
  var object = {}
  object.name = name
  object.age = age
  object.isAdult = age &gt;= 2.6
  object.__proto__ = createDog.prototype

  return object
}
createDog.prototype = {
  say: function () {
    console.log(`狗子汪汪汪`)
  }
}
</code></pre><p>接下来我们来玩一下</p>
<pre><code>var ergou = createDog(&apos;ergouzi&apos;, 30)
var dagou = createDog(&apos;dagouzi&apos;, 50)
dagou.say()
ergou.say()
console.log(dagou.say === ergou.say)
ergou.gender = &apos;女性&apos;
console.log(ergou)
console.log(dagou.gender)
console.log(ergou.say === dagou.say)
ergou.say = function () {
  console.log(&apos;汪汪汪 二狗子&apos;)
}
ergou.say()
console.log(dagou.say === ergou.say)
</code></pre><p>JS 中对象函数没有关系，JS 之父通过 this 强行使得它们有关系。<br><code>obj.fn.call(obj, 1,2,3) =&gt; obj.fn(1,2,3)</code></p>
<h3 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h3><p>我们假设在兵营中制造士兵，一个士兵在计算机中有一堆属性<br>有兵种 攻击力 生命值 行走 跑 死亡 攻击 防御<br>我们可以这样制造一个士兵</p>
<p>var 士兵 = {<br>ID: 1,<br>兵种: ‘步兵’,<br>攻击力: 5,<br>生命值: 100,<br>行走: function () { },<br>奔跑: function () { },<br>死亡: function () { },<br>攻击: function () { },<br>防御: function () { },<br>}<br>兵营.制造(士兵)</p>
<p>如果需要 100 个士兵怎么办呢？ 循环 100 次吧</p>
<pre><code>var 士兵们 = []
var 士兵
for (let i = 0; i &lt; 100; i++) {
  士兵 = {
    ID: 1,
    兵种: &apos;步兵&apos;,
    攻击力: 5,
    生命值: 100,
    行走: function () { },
    奔跑: function () { },
    死亡: function () { },
    攻击: function () { },
    防御: function () { },
  }
  士兵们.push(士兵)
}
兵营.批量制造(士兵们)
</code></pre><p>上面的代码浪费了很多内存，<br>这些 function 行为对于每一个士兵都是一样的，引用同一个函数就可以了<br>这些士兵的兵种和攻击力是一样的，没必要创建 100 次<br>只有 ID 和生命值需要创建 100 次，因为每个士兵都有自己的 ID 和生命值</p>
<pre><code>var 士兵原型 = {
  兵种: &apos;步兵&apos;,
  攻击力: 5,
  行走: function () { },
  奔跑: function () { },
  死亡: function () { },
  攻击: function () { },
  防御: function () { },
}
var 士兵们 = []
var 士兵
for (let i = 0; i &lt; 100; i++) {
  士兵 = {
    ID: i,
    生命值: 100
  }
  士兵.__proto__ = 士兵原型
  士兵们.push(士兵)
}

兵营.批量制造(士兵们)
</code></pre><p>有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来</p>
<pre><code>function 士兵(ID) {
  var o = {}
  o.__proto__ = 士兵.原型
  o.ID = ID
  o.生命值 = 42
  return o
}
士兵.原型 = {
  兵种: &apos;步兵&apos;,
  攻击力: 5,
  行走: function () { },
  奔跑: function () { },
  死亡: function () { },
  攻击: function () { },
  防御: function () { },
}
var 士兵们 = []
for (var i = 0; i &lt; 100; i++) {
  士兵们.push(士兵(i))
}
兵营.批量制造(士兵们)
</code></pre><p>JS 之父创建了 new，可以让我们少写几行代码</p>
<pre><code>function 士兵(ID) {
  var o = {} // 帮你创建临时对象
  o.__proto__ = 士兵.原型 // 帮你绑定原型
  o.ID = ID
  o.生命值 = 42
  return o // 帮你返回对象
}
士兵.原型 = {} // 统一焦作 prototype
</code></pre><p>只要你在士兵前面使用 new 关键字，那么至少做四件事情</p>
<ol>
<li>不用创建临时对象，因为 new 会帮你做 [使用 this 就能获取到临时对象，把 this 指向了临时对象]</li>
<li>不用绑定原型，因为 new 会帮你做，new 为了知道原型在哪，所以指定原型的名字为 prototype</li>
<li>不用 return 对象，因为 new 会帮你做</li>
<li>不要给原型想名字了，因为 new 指定名字为 prototype</li>
</ol>
<p>这一次 我们用 new 来写</p>
<pre><code>function 士兵(ID) {
  this.ID = ID
  this.生命值 = 42
}
士兵.原型 = {
  兵种: &apos;步兵&apos;,
  攻击力: 5,
  行走: function () { },
  奔跑: function () { },
  死亡: function () { },
  攻击: function () { },
  防御: function () { },
}
var 士兵们 = []
for (var i = 0; i &lt; 100; i++) {
  士兵们.push(new 士兵(i))
}
兵营.批量制造(士兵们)
</code></pre><p>new 的作用就是省那么几行代码，就是所谓的语法糖<br>功能就是 用构造函数构造出了对象，实现了自身属性和共用属性</p>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>new 操作为了记录 [零时对象是由哪个函数创建的]，所以预先给 [士兵.prototype] 加了一个 constructor 属性</p>
<pre><code>士兵.prototype = {
  constructor: 士兵
}
</code></pre><p>所以如果你想留着 constructor 就别直接覆盖 prototype<br>当然你也可以给自己的 constructor 重新赋值</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>最后说 <code>__proto__</code>，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 <code>obj.__proto__</code> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="iiicon">
            
              <p class="site-author-name" itemprop="name">iiicon</p>
              <p class="site-description motion-element" itemprop="description">coding note and life perception 代码笔记和生活感悟</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">117</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iiicon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
